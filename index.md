#索引压缩
倒排索引包含两个部分：单词词典和倒排列表。所以针对索引的压缩算法也分为针对词典的压缩和针对倒排列表的压缩。

##词典压缩

为了加快查询速度，词典数据一般是load到内存的。
无论是哈希加链表的链表内部，还是B树的叶子节点，存储的单词相关信息至少都包括：单词本身，文档频率，指向倒排列表的指针。对某个词典项来说，后两项各自使用4个字节表示即可。然而单词本身内容可长可短，若分配定长空间，则浪费严重，可使用优化的数据结构来节省内存空间。

优化1：将单词练习存储在某个内存区域，原先存储单词内容的部分由指向这个存储区对应单词起始位置的指针代替，单词结尾用词典中下一个单词的指针所指向位置来判断

优化2：将连续词典分块，原先每个词典项都需要保留一个指针，而分块之后，块内的词典项可以共享同一个指针。此时为了能标出其分隔位置，需要为每个单词增加单词长度信息。

##倒排列表压缩算法

倒排列表记录3类信息：文档编号，词频，单词位置序列。
文档编号及单词位置序列是递增的，所以通常做法是存储其差值。经过差值转换，这两类信息会转变为大量的小整数，词频本来就大部分是小整数。数字分布严重不平衡，小数值占领相当大比例是倒排列表数据的特点。

###压缩算法的评价指标
1. 压缩率
2. 压缩速度(相对不重要一些)
3. 解压速度

###一元编码(Unary Code)与二进制编码(Binary Code)
这两类编码是所有倒排列表压缩算法的基本构成元素，不论压缩算法内部逻辑思路如何，最终都要以这两种格式来对数据进行表示。要没以两种编码混合的方式，要么以单独二进制编码的方式。
1. Unary Code 对于整数X，使用X - 1个二进制数字1和末尾一个数字0表示这个整数。仅适合表示非常小的整数。
2. Binary Code 由二进制数字0和1进行组合表示实际数据。不同比特宽度代表了不同的数字表示范围。

###各类具体压缩算法见书

##文档编号重排序
建立索引的过程中，需要对每个网页进行编号，并在倒排列表中记录文档编号差值。文档编号重排序的目的在于减小倒排列表中相邻文档的差值，因为对更小的值使用压缩算法的效率更高。基于内容相似的网页所使用词汇大部分重叠的思路，将其依次编号，就能使得倒排列表中差值缩小。
策略：先文本聚类，再重新编号。
实际应用中，由于互联网数据量巨大，文本聚类速度难以满足。一种有效的启发规则是：将页面URL相似的网页聚合在一起，之后再进行聚类。

##静态索引裁剪(Static Index Pruning)
_有损压缩_
思路：将不重要的索引项从倒排列表中清除，可有效减少索引大小。

###以单词为中心的索引裁剪
假设已有相似性计算函数g(term,doc),此函数可以计算倒排索引中某个单词和其对应倒排列表中某个文档的相似性，就可以利用这个函数的计算结果来作为是否保留某个索引项的评判标准。

裁剪策略：
1. 设定相似性得分的阈值，会导致将某些单词的索引项全部清除
2. 每个单词至少保留K个索引项，对于多于K个索引项的单词，除保留K项之外，对第K项乘以折扣因子，得出阈值a.
然而以上只是“理想化”的裁剪过程，实验证明裁剪数量很少。后续实验证明，先对所有索引项的原始得分减去得分最低的索引项的得分，之后再采取如上过程，效果会显著提升。


###以文档为中心的索引裁剪
此法可认为是建立索引之前进行的数据预处理。
首先判断文档包含单词的重要性，经过重要性得分计算，保留重要单词，抛弃不重要单词，然后才建立倒排索引。
会导致某些词的倒排列表为空。